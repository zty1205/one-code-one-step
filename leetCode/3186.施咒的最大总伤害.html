<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>3186. 施咒的最大总伤害</title>
  </head>
  <body>
    <script src="../helper/common.js"></script>
    <script src="../helper/node.js"></script>
    <script src="../helper/tree.js"></script>
    <script src="../helper/graph.js"></script>
    <script src="../helper/command.js"></script>
    <script>
      // https://leetcode.cn/problems/maximum-total-damage-with-spell-casting/?envType=daily-question&envId=2025-12-03

      // 一个魔法师有许多不同的咒语。
      // 给你一个数组 power ，其中每个元素表示一个咒语的伤害值，可能会有多个咒语有相同的伤害值。
      // 已知魔法师使用伤害值为 power[i] 的咒语时，他们就 不能 使用伤害为 power[i] - 2 ，power[i] - 1 ，power[i] + 1 或者 power[i] + 2 的咒语。
      // 每个咒语最多只能被使用 一次 。
      // 请你返回这个魔法师可以达到的伤害值之和的 最大值 。
      //
      // 提示：
      // 1 <= power.length <= 105
      // 1 <= power[i] <= 109

      /**
       * @param {number[]} power
       * @return {number}
       */
      var maximumTotalDamage = function (power) {};

      // --- answer-1 ---

      // dp[i] 表示到第 i 个元素为止，可以造成的最大伤害
      // 数据过大 数组溢出
      var maximumTotalDamage = function (power = []) {
        const dp = [];
        const getDp = (n) => dp[n] || 0;

        for (const n of power) {
          dp[n] = getDp(n) + n;
        }
        console.log('dp after sum = ', [...dp]);
        let max = 0;
        for (let i = 1; i < dp.length; i++) {
          dp[i] = Math.max(getDp(i - 1), getDp(i - 2), getDp(i - 3) + getDp(i));
          max = Math.max(max, dp[i]);
        }
        console.log('dp after max = ', [...dp]);
        return max;
      };

      // --- answer-1 ---

      var maximumTotalDamage = function (power = []) {
        const map = new Map();
        for (const n of power) {
          map.set(n, (map.get(n) || 0) + n);
        }
        console.log('map = ', map);
        const vec = [[0, 0], ...map.entries()].sort((a, b) => a[0] - b[0]);
        console.log('vec = ', vec);
        let f = new Array(vec.length).fill(0);
        let max = 0;
        let ans = 0;
        let j = 1;
        for (let i = 1; i < vec.length; i++) {
          // 找到伤害超过2的最大的值
          while (j < i && vec[j][0] < vec[i][0] - 2) {
            max = Math.max(max, f[j]);
            j++;
          }
          f[i] = max + vec[i][1];
          ans = Math.max(ans, f[i]);
        }
        return ans;
      };

      // --- answer-2 ---

      // --- answer-2 ---

      var power = [1, 1, 3, 4];
      var result = 6;

      var power = [7, 1, 6, 6];
      var reuslt = 13;

      console.log('power = ', power);
      console.log('result = ', result);
      console.log('maximumTotalDamage = ', maximumTotalDamage(power));
    </script>
  </body>
</html>
