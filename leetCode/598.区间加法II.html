<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>598. 区间加法 II</title>
  </head>
  <body>
    <script src="../helper/common.js"></script>
    <script src="../helper/node.js"></script>
    <script src="../helper/tree.js"></script>
    <script src="../helper/graph.js"></script>
    <script src="../helper/command.js"></script>
    <script>
      // https://leetcode.cn/problems/range-addition-ii/?envType=daily-question&envId=2025-05-15

      // 给你一个 m x n 的矩阵 M 和一个操作数组 op 。矩阵初始化时所有的单元格都为 0 。ops[i] = [ai, bi] 意味着当所有的 0 <= x < ai 和 0 <= y < bi 时， M[x][y] 应该加 1。
      // 在 执行完所有操作后 ，计算并返回 矩阵中最大整数的个数 。
      //
      // 提示：
      // 1 <= m, n <= 4 * 104
      // 0 <= ops.length <= 104
      // ops[i].length == 2
      // 1 <= ai <= m
      // 1 <= bi <= n

      /**
       * @param {number} m
       * @param {number} n
       * @param {number[][]} ops
       * @return {number}
       */
      var maxCount = function (m, n, ops) {};

      // --- answer-1 ---

      // 暴力
      var maxCount = function (m = 1, n = 1, ops = []) {
        const matrix = Array.from({ length: m }, () => Array(n).fill(0));

        let max = 0;
        let cnt = 0;
        if (ops.length === 0) {
          return cnt;
        }
        for (const [a, b] of ops) {
          for (let i = 0; i < a; i++) {
            for (let j = 0; j < b; j++) {
              matrix[i][j]++;
              if (matrix[i][j] > max) {
                max = matrix[i][j];
                cnt = 1;
              } else if (matrix[i][j] === max) {
                cnt++;
              }
            }
          }
        }
        return cnt;
      };

      // --- answer-1 ---

      // --- answer-2 ---

      // 结果一定是 i * j 的形式
      var maxCount = function (m = 1, n = 1, ops = []) {
        if (ops.length === 0) {
          return m * n;
        }
        let minRow = m;
        let minCol = n;
        for (const [a, b] of ops) {
          minRow = Math.min(minRow, a);
          minCol = Math.min(minCol, b);
        }
        return minRow * minCol;
      };

      // --- answer-2 ---

      var m = 3,
        n = 3,
        ops = [
          [2, 2],
          [3, 3]
        ];
      var result = 4;
      // 解释: M 中最大的整数是 2, 而且 M 中有4个值为2的元素。因此返回 4。

      // var  m = 3, n = 3, ops = [[2,2],[3,3],[3,3],[3,3],[2,2],[3,3],[3,3],[3,3],[2,2],[3,3],[3,3],[3,3]];
      // var result =  4;

      var m = 3,
        n = 3,
        ops = [];
      var result = 9;

      console.log('m = ', m);
      console.log('n = ', n);
      console.log('ops = ', ops);
      console.log('result = ', result);
      console.log('maxCount = ', maxCount(m, n, ops));
    </script>
  </body>
</html>
