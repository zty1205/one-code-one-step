<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>1695. 删除子数组的最大得分</title>
  </head>
  <body>
    <script src="../helper/common.js"></script>
    <script src="../helper/node.js"></script>
    <script src="../helper/tree.js"></script>
    <script src="../helper/graph.js"></script>
    <script src="../helper/command.js"></script>
    <script>
      // https://leetcode.cn/problems/maximum-erasure-value/?envType=daily-question&envId=2025-07-22

      // 给你一个正整数数组 nums ，请你从中删除一个含有 若干不同元素 的子数组。删除子数组的 得分 就是子数组各元素之 和 。
      // 返回 只删除一个 子数组可获得的 最大得分 。
      // 如果数组 b 是数组 a 的一个连续子序列，即如果它等于 a[l],a[l+1],...,a[r] ，那么它就是 a 的一个子数组。
      //
      // 提示：
      // 1 <= nums.length <= 105
      // 1 <= nums[i] <= 104

      /**
       * @param {number[]} nums
       * @return {number}
       */
      var maximumUniqueSubarray = function (nums) {};

      // --- answer-1 ---

      // 连续的数组，且没有重复， 和最大
      var maximumUniqueSubarray = function (nums = []) {
        const map = new Map(); // 记录每个数字的索引
        const preSum = [0]; // 前缀和数组

        for (let i = 0; i < nums.length; i++) {
          preSum[i + 1] = preSum[i] + nums[i]; // 计算前缀和
        }

        let maxSum = 0; // 最大和
        let start = 0; // 当前子数组的起始索引
        for (let i = 0; i < nums.length; i++) {
          if (map.has(nums[i])) {
            // 如果当前数字已经存在于 map 中，更新 start
            start = Math.max(start, map.get(nums[i]) + 1);
          }
          map.set(nums[i], i); // 更新当前数字的索引
          maxSum = Math.max(maxSum, preSum[i + 1] - preSum[start]); // 计算当前子数组的和
        }
        return maxSum; // 返回最大和
      };

      var maximumUniqueSubarray = function (nums) {
        const n = nums.length;
        const psum = new Array(n + 1).fill(0);
        const cnt = new Map();
        let ans = 0,
          pre = 0;
        for (let i = 0; i < n; ++i) {
          psum[i + 1] = psum[i] + nums[i];
          pre = Math.max(pre, cnt.get(nums[i]) || 0);
          ans = Math.max(ans, psum[i + 1] - psum[pre]);
          cnt.set(nums[i], i + 1);
        }
        return ans;
      };

      // --- answer-1 ---

      // --- answer-2 ---

      // 滑动窗口
      var maximumUniqueSubarray = function (nums) {
        const n = nums.length;
        const seen = new Set();
        let ans = 0,
          psum = 0;
        for (let i = 0, j = 0; i < n; ++i) {
          psum += nums[i];
          while (seen.has(nums[i])) {
            seen.delete(nums[j]);
            psum -= nums[j];
            j++;
          }
          seen.add(nums[i]);
          ans = Math.max(ans, psum);
        }
        return ans;
      };

      // --- answer-2 ---

      var nums = [4, 2, 4, 5, 6];
      var result = 17;
      // 解释：最优子数组是 [2,4,5,6]

      var nums = [5, 2, 1, 2, 5, 2, 1, 2, 5];
      var result = 8;
      // 解释：最优子数组是 [5,2,1] 或 [1,2,5]

      console.log('nums = ', nums);
      console.log('result = ', result);
      console.log('maximumUniqueSubarray = ', maximumUniqueSubarray(nums));
    </script>
  </body>
</html>
