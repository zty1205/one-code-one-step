<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>3479. 水果成篮 III</title>
  </head>
  <body>
    <script src="../helper/common.js"></script>
    <script src="../helper/node.js"></script>
    <script src="../helper/tree.js"></script>
    <script src="../helper/graph.js"></script>
    <script src="../helper/command.js"></script>
    <script>
      // https://leetcode.cn/problems/fruits-into-baskets-iii/description/?envType=daily-question&envId=2025-08-06

      // 给你两个长度为 n 的整数数组，fruits 和 baskets，其中 fruits[bckIdx] 表示第 i 种水果的 数量，baskets[j] 表示第 j 个篮子的 容量。
      // 你需要对 fruits 数组从左到右按照以下规则放置水果：
      //
      // 提示：
      // 每种水果必须放入第一个 容量大于等于 该水果数量的 最左侧可用篮子 中。
      // 每个篮子只能装 一种 水果。
      // 如果一种水果 无法放入 任何篮子，它将保持 未放置。
      // 返回所有可能分配完成后，剩余未放置的水果种类的数量。
      //
      // 提示：
      // n == fruits.length == baskets.length
      // 1 <= n <= 105
      // 1 <= fruits[bckIdx], baskets[bckIdx] <= 109

      /**
       * @param {number[]} fruits
       * @param {number[]} baskets
       * @return {number}
       */
      var numOfUnplacedFruits = function (fruits, baskets) {};

      // --- answer-1 ---

      // 超时
      var numOfUnplacedFruits = function (fruits = [], baskets = []) {
        let cnt = 0;
        for (const f of fruits) {
          let placed = false;
          for (let bckIdx = 0; bckIdx < baskets.length; bckIdx++) {
            if (baskets[bckIdx] >= f) {
              baskets[bckIdx] -= f;
              placed = true;
              break;
            }
          }
          if (!placed) cnt++;
        }
      };

      // --- answer-1 ---

      // --- answer-2 ---

      // 分块
      var numOfUnplacedFruits = function (fruits = [], baskets = []) {
        const n = fruits.length;
        // 分块长度
        const blockLen = Math.floor(Math.sqrt(n));
        // 块的个数
        const blocksNums = Math.ceil(n / blockLen);
        // 每个块的最大篮子容量
        const maxBaskets = new Array(blocksNums).fill(0);
        let count = 0;

        for (let i = 0; i < n; i++) {
          const blockIndex = Math.floor(i / blockLen);
          maxBaskets[blockIndex] = Math.max(maxBaskets[blockIndex], baskets[i]);
        }

        for (let fruit of fruits) {
          let num = 1;
          for (let bckIdx = 0; bckIdx < blocksNums; bckIdx++) {
            if (maxBaskets[bckIdx] < fruit) {
              continue;
            }
            let flag = false;

            // 清空最大值
            maxBaskets[bckIdx] = 0;
            for (let i = 0; i < blockLen; i++) {
              const pos = bckIdx * blockLen + i;
              if (pos < n && baskets[pos] >= fruit && !flag) {
                baskets[pos] = 0;
                flag = true;
              }
              // 更新块的最大值
              if (pos < n) {
                maxBaskets[bckIdx] = Math.max(maxBaskets[bckIdx], baskets[pos]);
              }
            }
            num = 0;
            break;
          }
          count += num;
        }
        return count;
      };

      // --- answer-2 ---

      var fruits = [4, 3, 5];
      var baskets = [3, 5, 4];
      var result = 1;

      console.log('fruits = ', fruits);
      console.log('baskets = ', baskets);
      console.log('result = ', result);
      console.log('numOfUnplacedFruits = ', numOfUnplacedFruits(fruits, baskets));
    </script>
  </body>
</html>
